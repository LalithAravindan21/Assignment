# -*- coding: utf-8 -*-
"""score_wallets.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pTaDAoYhrtFtomC4AEIuJ7N_cz3TqKr5
"""

# score_wallets.py
import json
import pandas as pd
from datetime import datetime
import numpy as np

def calculate_decimals(asset_symbol):
    """
    Heuristic to determine token decimals based on common symbols.
    This is a simplification due to lack of explicit decimal information in the dataset.
    """
    if asset_symbol == 'USDC':
        return 6
    elif asset_symbol in ['WMATIC', 'WETH', 'DAI', 'WPOL']: # Assuming WPOL is 18 decimals like WMATIC/WETH/DAI
        return 18
    else:
        # Default to 18 for other unknown ERC-20 tokens, or handle as needed
        return 18

def score_wallets(transactions_file):
    """
    Loads transaction data, engineers features, and assigns a credit score to each wallet.
    """
    with open(transactions_file, 'r') as f:
        transactions = json.load(f)

    df = pd.DataFrame(transactions)

    # --- Preprocessing ---
    df['timestamp_dt'] = pd.to_datetime(df['timestamp'], unit='s')

    # Calculate USD value for each transaction
    def get_usd_value(row):
        try:
            amount_raw = float(row['actionData']['amount'])
            asset_price_usd = float(row['actionData']['assetPriceUSD'])
            asset_symbol = row['actionData']['assetSymbol']
            decimals = calculate_decimals(asset_symbol)
            return (amount_raw / (10**decimals)) * asset_price_usd
        except (ValueError, KeyError, TypeError):
            return 0 # Handle cases where data might be missing or malformed

    df['amount_usd'] = df.apply(get_usd_value, axis=1)

    # --- Feature Engineering ---
    wallet_features = {}

    for wallet, group in df.groupby('userWallet'):
        deposits = group[group['action'] == 'deposit']
        borrows = group[group['action'] == 'borrow']
        repays = group[group['action'] == 'repay']
        redeems = group[group['action'] == 'redeemunderlying']
        liquidations = group[group['action'] == 'liquidationcall']

        # Activity Metrics
        total_transactions = len(group)
        unique_days_active = group['timestamp_dt'].dt.date.nunique()
        activity_span_days = (group['timestamp_dt'].max() - group['timestamp_dt'].min()).days if len(group) > 1 else 0
        avg_tx_per_day = total_transactions / unique_days_active if unique_days_active > 0 else 0

        # Financial Behavior Metrics
        total_deposit_usd = deposits['amount_usd'].sum()
        total_borrow_usd = borrows['amount_usd'].sum()
        total_repay_usd = repays['amount_usd'].sum()
        total_redeem_usd = redeems['amount_usd'].sum()
        total_liquidation_usd = liquidations['amount_usd'].sum()

        net_deposit_usd = total_deposit_usd - total_redeem_usd
        net_borrow_usd = total_borrow_usd - total_repay_usd

        borrow_to_deposit_ratio = total_borrow_usd / total_deposit_usd if total_deposit_usd > 0 else 0
        repay_to_borrow_ratio = total_repay_usd / total_borrow_usd if total_borrow_usd > 0 else 0

        liquidation_flag = 1 if len(liquidations) > 0 else 0
        num_liquidations = len(liquidations)
        liquidation_frequency = num_liquidations / total_transactions if total_transactions > 0 else 0

        # Asset Diversity
        unique_assets_deposited = deposits['actionData'].apply(lambda x: x.get('assetSymbol')).nunique()
        unique_assets_borrowed = borrows['actionData'].apply(lambda x: x.get('assetSymbol')).nunique()

        wallet_features[wallet] = {
            'total_transactions': total_transactions,
            'unique_days_active': unique_days_active,
            'activity_span_days': activity_span_days,
            'avg_tx_per_day': avg_tx_per_day,
            'total_deposit_usd': total_deposit_usd,
            'total_borrow_usd': total_borrow_usd,
            'total_repay_usd': total_repay_usd,
            'total_redeem_usd': total_redeem_usd,
            'total_liquidation_usd': total_liquidation_usd,
            'net_deposit_usd': net_deposit_usd,
            'net_borrow_usd': net_borrow_usd,
            'borrow_to_deposit_ratio': borrow_to_deposit_ratio,
            'repay_to_borrow_ratio': repay_to_borrow_ratio,
            'liquidation_flag': liquidation_flag,
            'num_liquidations': num_liquidations,
            'liquidation_frequency': liquidation_frequency,
            'unique_assets_deposited': unique_assets_deposited,
            'unique_assets_borrowed': unique_assets_borrowed,
        }

    features_df = pd.DataFrame.from_dict(wallet_features, orient='index')

    # --- Scoring Logic ---
    # Apply min-max scaling to features that contribute positively/negatively
    # Handle potential NaN/Inf values from division by zero before scaling
    features_df.replace([np.inf, -np.inf], np.nan, inplace=True)
    features_df.fillna(0, inplace=True) # Fill NaNs with 0 after handling inf

    # Define features and their weights for raw score calculation
    # Weights are conceptual and can be tuned
    feature_weights = {
        'total_deposit_usd': 0.25,
        'repay_to_borrow_ratio': 0.30, # Higher is better, capped at 1.0 for perfect repayment
        'activity_span_days': 0.15,
        'unique_days_active': 0.10,
        'num_liquidations': -0.40, # Negative weight for liquidations
        'net_borrow_usd': -0.10, # Negative if net borrow is high (unrepaid)
        'unique_assets_deposited': 0.05,
        'total_transactions': 0.05,
    }

    # Scale features to 0-1 range for weighted sum
    scaled_features = pd.DataFrame(index=features_df.index)
    for feature, weight in feature_weights.items():
        if feature in ['num_liquidations', 'net_borrow_usd']: # Features where lower is better for score
            # For negative impact features, scale such that higher values result in lower scaled scores
            # Or simply apply negative weight to min-max scaled value
            min_val = features_df[feature].min()
            max_val = features_df[feature].max()
            if max_val == min_val:
                scaled_features[feature] = 0
            else:
                scaled_features[feature] = 1 - ((features_df[feature] - min_val) / (max_val - min_val))
        elif feature == 'repay_to_borrow_ratio':
            # Cap repay_to_borrow_ratio at 1.0, as >1 doesn't necessarily mean better credit
            scaled_features[feature] = features_df[feature].clip(upper=1.0)
            min_val = scaled_features[feature].min()
            max_val = scaled_features[feature].max()
            if max_val == min_val:
                scaled_features[feature] = 0
            else:
                scaled_features[feature] = (scaled_features[feature] - min_val) / (max_val - min_val)
        else: # Features where higher is better for score
            min_val = features_df[feature].min()
            max_val = features_df[feature].max()
            if max_val == min_val:
                scaled_features[feature] = 0
            else:
                scaled_features[feature] = (features_df[feature] - min_val) / (max_val - min_val)

    # Calculate raw composite score
    raw_scores = pd.Series(0.0, index=features_df.index)
    for feature, weight in feature_weights.items():
        raw_scores += scaled_features[feature] * abs(weight) # Use absolute weight for summation, sign handled by scaling

    # Adjust for specific negative impacts (e.g., direct liquidation penalty)
    # Wallets with any liquidations get a base penalty
    raw_scores -= features_df['liquidation_flag'] * 0.5 # Significant penalty for any liquidation

    # Normalize raw scores to 0-1000 range
    min_raw_score = raw_scores.min()
    max_raw_score = raw_scores.max()

    if max_raw_score == min_raw_score:
        final_scores = pd.Series(500, index=raw_scores.index) # All scores are 500 if no variance
    else:
        final_scores = ((raw_scores - min_raw_score) / (max_raw_score - min_raw_score)) * 1000
        # Ensure scores are within 0-1000 and round to nearest integer
        final_scores = final_scores.round().astype(int)
        final_scores = final_scores.clip(0, 1000)

    # Create a DataFrame for output
    scored_wallets = pd.DataFrame({
        'userWallet': final_scores.index,
        'credit_score': final_scores.values
    })

    return scored_wallets, features_df

if __name__ == "__main__":
    transactions_file = '/content/user-wallet-transactions.json'
    output_scores_file = '/content/wallet_scores.csv'
    output_features_file = '/content/wallet_features.csv'

    scored_wallets_df, features_df = score_wallets(transactions_file)

    scored_wallets_df.to_csv(output_scores_file, index=False)
    features_df.to_csv(output_features_file) # Save features for analysis

    print(f"Wallet scores saved to {output_scores_file}")
    print(f"Wallet features saved to {output_features_file}")

    # Optional: Display some results
    print("\nTop 10 Wallets by Credit Score:")
    print(scored_wallets_df.sort_values(by='credit_score', ascending=False).head(10))

    print("\nBottom 10 Wallets by Credit Score:")
    print(scored_wallets_df.sort_values(by='credit_score', ascending=True).head(10))

    # Generate data for analysis.md
    score_ranges = [0, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1001]
    score_labels = [f'{i}-{i+99}' for i in range(0, 1000, 100)]
    score_distribution = pd.cut(scored_wallets_df['credit_score'], bins=score_ranges, labels=score_labels, right=False).value_counts().sort_index()

    print("\nScore Distribution:")
    print(score_distribution)

    # Example analysis for analysis.md
    low_score_wallets = scored_wallets_df[scored_wallets_df['credit_score'] <= 300].sort_values(by='credit_score').head(3)
    high_score_wallets = scored_wallets_df[scored_wallets_df['credit_score'] >= 700].sort_values(by='credit_score', ascending=False).head(3)

    print("\nFeatures for a few low-score wallets:")
    for wallet in low_score_wallets['userWallet']:
        print(f"\nWallet: {wallet}")
        print(features_df.loc[wallet][['total_transactions', 'total_deposit_usd', 'total_borrow_usd', 'total_repay_usd', 'num_liquidations', 'repay_to_borrow_ratio', 'activity_span_days']])

    print("\nFeatures for a few high-score wallets:")
    for wallet in high_score_wallets['userWallet']:
        print(f"\nWallet: {wallet}")
        print(features_df.loc[wallet][['total_transactions', 'total_deposit_usd', 'total_borrow_usd', 'total_repay_usd', 'num_liquidations', 'repay_to_borrow_ratio', 'activity_span_days']])

